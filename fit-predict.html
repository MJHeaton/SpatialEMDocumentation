<!doctype html>
<html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fit-predict.html</title>
<link rel="stylesheet" href="style.css"/>
</head>
<body>
<header><div class="wrap nav">
<a href="index.html">Home</a>
<a href="vignette.html">Vignette</a>
<a href="fit-predict.html">Fit & Predict</a>
<a href="tuning.html">Tuning</a>
<a href="vecchia.html">Vecchia</a>
<a href="utilities.html">Utilities</a>
<a href="ml-backend.html">ML Backends</a>
<a href="concepts.html">Concepts</a>
</div></header>
<main><div class="wrap">

<h1>Fit & Predict</h1>


<div class="card">
  <h2 style="margin-top:0">Table of contents</h2>
  <ul>
    <li><strong>Public wrappers</strong></li>
    <ul>
      <li><a href="#fit_spatial_em"><code>fit_spatial_em()</code></a></li>
      <li><a href="#predict.spatial_em"><code>predict.spatial_em()</code></a></li>
    </ul>
    <li><strong>Backend</strong></li>
    <ul>
      <li><a href="#fit_spatial_em_probit"><code>fit_spatial_em_probit()</code></a></li>
      <li><a href="#predict_spatial_em_probit"><code>predict_spatial_em_probit()</code></a></li>
    </ul>
  </ul>
</div>
<div class="card public"><h2 style="margin-top:0">Public wrappers</h2><p class="muted">Stable user-facing API: use these functions to fit and predict.</p></div>
<div class="card" id="fit_spatial_em">
<h3><code>fit_spatial_em()</code></h3>
<h4>Purpose</h4>
<p>
  Public entry point for fitting Spatial EM models. This is a thin wrapper that:
  (1) validates <code>family</code> and <code>ml_model</code>,
  (2) dispatches to a family-specific fitter (currently <code>fit_spatial_em_probit()</code>),
  and (3) adds the generic class <code>"spatial_em"</code> to the returned fit object for S3 dispatch
  (e.g., <code>predict()</code>).
</p>

<h4>Example call</h4>
<pre><code> fit &lt;- fit_spatial_em(
  formula  = y ~ x1 + x2 + x3,
  data     = dat,
  coords   = c("lon","lat"),
  family   = "probit",
  ml_model = "xgboost",

  # forwarded to fit_spatial_em_{family}(...):
  correlation_params = list(range = 0.25, nugget = 1e-6, smoothness = 1.5),
  max_neighbors      = 30,
  ordering           = "maxmin",
  em_max_iter        = 30,
  em_tol             = 1e-3,
  damping            = 0.7,
  ml_args            = list(max_depth = 4, eta = 0.1),
  init_method        = "ranger",
  verbose            = TRUE
)</code></pre>

<h4>Inputs</h4>
<ul>
  <li><code>formula</code> — Model formula specifying the response and covariates.</li>

  <li><code>data</code> — Data frame containing response, covariates, and coordinate columns.</li>

  <li><code>coords</code> — Coordinate specification used to extract locations from <code>data</code>
      (typically a character vector of column names like <code>c("x","y")</code>).</li>

  <li><code>family</code> — Observation family. Currently supports:
    <ul>
      <li><code>"probit"</code></li>
    </ul>
  </li>

  <li><code>ml_model</code> — Mean-model backend used inside the family-specific fitter. Currently supports:
    <ul>
      <li><code>"ranger"</code></li>
      <li><code>"lm"</code></li>
      <li><code>"xgboost"</code></li>
    </ul>
  </li>

  <li><code>...</code> — Additional arguments forwarded to the family-specific fit function
      (currently <code>fit_spatial_em_probit()</code>). This is where you supply the spatial correlation settings,
      EM controls, ML hyperparameters (<code>ml_args</code>), initialization choices, etc.</li>
</ul>

<h4>Outputs</h4>
<ul>
  <li>
    Returns a fitted model object produced by the family-specific fitter (currently class
    <code>"spatial_em_probit"</code>), with the generic class <code>"spatial_em"</code> prepended for S3 dispatch.
    In other words:
    <code>class(fit) = c("spatial_em", "spatial_em_probit")</code> (plus any additional classes the backend may include).
  </li>
  <li>
    The returned object contains everything needed for prediction and inspection, including:
    <code>terms</code>, <code>vecchia</code>, <code>correlation_params</code>, the trained ML mean-model fit,
    and latent-field state (<code>Zw</code>, <code>Z_hat</code>) (exact contents depend on the family backend).
  </li>
</ul>
</div>

<div class="card" id="predict.spatial_em">
<h3><code>predict.spatial_em()</code></h3>
<h4>Purpose</h4>
<p>
  Public S3 prediction method for fitted Spatial EM objects. This function validates the
  requested output <code>type</code> and dispatches to a model-family-specific prediction
  routine (currently <code>predict_spatial_em_probit()</code> for <code>"spatial_em_probit"</code> fits).
</p>

<h4>Example call</h4>
<pre><code># Fit using the public wrapper
fit &lt;- fit_spatial_em(
  formula  = y ~ x1 + x2 + x3,
  data     = dat,
  coords   = c("lon","lat"),
  family   = "probit",
  ml_model = "xgboost",
  correlation_params = list(range = 0.25, nugget = 1e-6, smoothness = 1.5),
  ml_args = list(max_depth = 4, eta = 0.1)
)

# Predict probabilities (default response scale for probit)
p_hat &lt;- predict(fit, newdata = dat_new, type = "response")

# Predict latent link scale Z (probit latent field)
z_hat &lt;- predict(fit, newdata = dat_new, type = "link")

# Predict whitened latent scale Zw (internal/diagnostics)
zw_hat &lt;- predict(fit, newdata = dat_new, type = "latent_w")</code></pre>

<h4>Inputs</h4>
<ul>
  <li><code>object</code> — A fitted Spatial EM object with class <code>"spatial_em"</code> and a
      supported family-specific class (e.g., <code>"spatial_em_probit"</code>).</li>

  <li><code>newdata</code> — Data frame of prediction locations. Must contain:
    <ul>
      <li>all covariates needed by the fitted model terms, and</li>
      <li>the coordinate columns specified by <code>coords</code>.</li>
    </ul>
  </li>

  <li><code>coords</code> — Coordinate specification (defaults to <code>object$coords</code>).</li>

  <li><code>type</code> — Output scale:
    <ul>
      <li><code>"response"</code>: predicted probabilities <code>P(Y=1)</code></li>
      <li><code>"link"</code>: correlated latent field <code>Z</code></li>
      <li><code>"latent_w"</code>: whitened latent field <code>Zw</code></li>
    </ul>
  </li>

  <li><code>...</code> — Additional arguments forwarded to the backend prediction function.</li>
</ul>

<h4>Outputs</h4>
<ul>
  <li>
    A numeric vector of predictions (length equals the number of valid prediction rows after any
    required missing-value filtering performed by the backend).
  </li>
  <li>
    The meaning of returned values depends on <code>type</code> and the model family.</li>
</ul>
</div>


<div class="card backend"><h2 style="margin-top:0">Backend: probit</h2><p class="muted">Model-specific implementations used by the public wrappers (probit family).</p></div>
<div class="card" id="fit_spatial_em_probit">
<h3><code>fit_spatial_em_probit()</code></h3>
<h4>Purpose</h4>
<p>
  Predict from a fitted probit Spatial EM model (<code>"spatial_em_probit"</code>) at new locations.
  The function:
  (1) rebuilds the design matrix for <code>newdata</code> using stored <code>terms</code>,
  (2) drops rows with missing required covariates while keeping coordinates aligned,
  (3) computes Vecchia-style prediction coefficients against training locations,
  (4) whitens new covariates (<code>Xw_new</code>),
  (5) predicts the whitened latent mean <code>Zw</code> using the fitted ML backend
      (<code>object$ml_model</code> / <code>object$ml_fit</code>),
  (6) re-correlates to the latent field scale <code>Z</code>,
  and (7) returns probabilities, <code>Z</code>, or <code>Zw</code> depending on <code>type</code>.
</p>

<h4>Example call</h4>
<pre><code># Predict probabilities P(Y=1)
p_hat &lt;- predict_spatial_em_probit(
  object  = fit_probit,
  newdata = dat_new,
  coords  = c("lon","lat"),
  type    = "response"
)

# Latent field on link scale (Z)
z_hat &lt;- predict_spatial_em_probit(fit_probit, dat_new, coords = c("lon","lat"), type = "link")

# Whitened latent scale (Zw)
zw_hat &lt;- predict_spatial_em_probit(fit_probit, dat_new, coords = c("lon","lat"), type = "latent_w")</code></pre>

<h4>Inputs</h4>
<ul>
  <li><code>object</code> — A fitted model object of class <code>"spatial_em_probit"</code>. Must contain
      <code>terms</code>, <code>vecchia</code>, <code>correlation_params</code>, <code>max_neighbors</code>,
      training <code>X</code>, training <code>Z_hat</code>, and ML components <code>ml_model</code> and <code>ml_fit</code>.</li>

  <li><code>newdata</code> — Data frame of prediction locations. Must include:
    <ul>
      <li>all covariates required by <code>object$terms</code></li>
      <li>coordinate columns specified by <code>coords</code></li>
    </ul>
    Rows with missing required covariates are removed (using <code>complete.cases()</code> on the model frame),
    and coordinates are extracted from the filtered rows to maintain alignment.
  </li>

  <li><code>coords</code> — Coordinate specification (defaults to <code>object$coords</code>).
      Typically a character vector like <code>c("x","y")</code> or <code>c("lon","lat")</code>.</li>

  <li><code>type</code> — Output scale:
    <ul>
      <li><code>"response"</code>: predicted probabilities <code>pnorm(Z_pred)</code></li>
      <li><code>"link"</code>: correlated latent field predictions <code>Z_pred</code></li>
      <li><code>"latent_w"</code>: whitened latent predictions <code>Zw_pred</code></li>
    </ul>
  </li>

  <li><code>...</code> — Additional arguments forwarded to the ML backend’s <code>predict()</code> method.
      (Useful for backends that accept prediction-time options.)</li>
</ul>

<h4>Outputs</h4>
<ul>
  <li>
    A numeric vector of length <code>m</code>, where <code>m</code> is the number of rows in <code>newdata</code>
    that remain after filtering missing required covariates.
  </li>
  <li>
    Returned values depend on <code>type</code>:
    <ul>
      <li><code>"latent_w"</code>: whitened latent predictions <code>Zw_pred</code></li>
      <li><code>"link"</code>: correlated latent predictions <code>Z_pred</code></li>
      <li><code>"response"</code>: probabilities <code>pnorm(Z_pred)</code></li>
    </ul>
  </li>
  <li class="muted">
    Notes:
    <ul>
      <li>Requires the <code>fields</code> package for <code>fields::Matern()</code>.</li>
      <li>Neighbor selection for prediction uses nearest training points (up to <code>max_neighbors</code>)
          in Vecchia order and computes coefficients via Cholesky solve.</li>
      <li>Small negative <code>v_u</code> values are optionally clamped to a tiny positive number for numerical stability.</li>
    </ul>
  </li>
</ul>
</div>



<div class="card" id="predict_spatial_em_probit">
<h3><code>predict_spatial_em_probit()</code></h3>
<h4>Purpose</h4>
<p>
  Generate predictions from a fitted <code>spatial_em_probit_ranger</code> model at new locations.
  This function:
  (1) rebuilds the design matrix for <code>newdata</code> using the stored model terms,
  (2) extracts coordinates for <code>newdata</code>,
  (3) whitens the new covariates using Vecchia-style conditional prediction coefficients computed
  against the training set,
  (4) predicts the whitened latent mean <code>Zw</code> using the stored ranger model,
  (5) re-correlates predictions back to the latent correlated scale <code>Z</code>,
  and (6) returns either probabilities (<code>response</code>), latent link-scale values (<code>link</code>),
  or whitened latent values (<code>latent_w</code>).
</p>

<h4>Example call</h4>
<pre><code># dat_new must contain the covariates used in the original formula
# and the coordinate columns specified by coords
p_hat &lt;- predict_spatial_em_probit(
  object  = fit,
  newdata = dat_new,
  coords  = c("lon","lat"),
  type    = "response"
)

# latent (probit) link scale (Z)
z_hat &lt;- predict_spatial_em_probit(
  fit, dat_new, coords = c("lon","lat"), type = "link"
)

# internal whitened latent scale (Zw)
zw_hat &lt;- predict_spatial_em_probit(
  fit, dat_new, coords = c("lon","lat"), type = "latent_w"
)</code></pre>

<h4>Inputs</h4>
<ul>
  <li><code>object</code> — A fitted model object of class <code>"spatial_em_probit_ranger"</code>
    (returned by <code>fit_spatial_em_probit()</code>).</li>

  <li><code>newdata</code> — Data frame of new observations to predict at. Must include:
    <ul>
      <li>all covariate columns required by <code>object$terms</code> (the original formula), and</li>
      <li>coordinate columns specified by <code>coords</code>.</li>
    </ul>
    Rows with missing values in required fields are dropped by <code>model.frame(..., na.action = na.omit)</code>.
    If all rows are dropped, the function errors.
  </li>

  <li><code>coords</code> — Coordinate specification for <code>get_locs_matrix(newdata, coords)</code>.
    Defaults to <code>object$coords</code> (so the fit object should store coordinates semantics).
    Typically a character vector like <code>c("x","y")</code> or <code>c("lon","lat")</code>.
  </li>

  <li><code>type</code> — Output scale:
    <ul>
      <li><code>"response"</code>: predicted probabilities <code>P(Y=1)</code> using probit link (<code>pnorm(Z_pred)</code>)</li>
      <li><code>"link"</code>: correlated latent/link scale <code>Z_pred</code></li>
      <li><code>"latent_w"</code>: whitened latent scale <code>Zw_pred</code></li>
    </ul>
  </li>

  <li><code>...</code> — Reserved for future extensions (currently unused in the pasted implementation).</li>
</ul>

<h4>Outputs</h4>
<ul>
  <li>Returns a numeric vector of length equal to the number of valid rows in <code>newdata</code>
      after applying the model frame (i.e., after dropping NAs).</li>
  <li>Returned values depend on <code>type</code>:
    <ul>
      <li><code>"latent_w"</code>: <code>Zw_pred</code> (whitened latent predictions from ranger on <code>Xw_new</code>)</li>
      <li><code>"link"</code>: <code>Z_pred</code> (re-correlated latent predictions)</li>
      <li><code>"response"</code>: <code>pnorm(Z_pred)</code> (probit probabilities)</li>
    </ul>
  </li>
</ul>
</div>

</div></main>
</body></html>
